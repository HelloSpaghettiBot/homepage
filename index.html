

  <script>
    // Game Classes
    class Particle {
      constructor(x, y, char) {
        this.x = x;
        this.y = y;
        this.char = char;
        this.velocity = {
          x: (Math.random() - 0.5) * 10,
          y: (Math.random() - 0.5) * 10
        };
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
        this.alpha = 1;
      }

      update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.rotation += this.rotationSpeed;
        this.alpha -= 0.01;
        return this.alpha > 0;
      }
    }

    class Asteroid {
      constructor(canvas) {
        this.canvas = canvas;
        this.x = Math.random() * canvas.width;
        this.y = Math.random() < 0.5 ? -30 : canvas.height + 30;
        this.size = Math.random() * 20 + 20;
        this.velocity = {
          x: (Math.random() - 0.5) * 4,
          y: (Math.random() - 0.5) * 4
        };
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.02;
        this.points = this.generatePoints();
      }

      generatePoints() {
        const points = [];
        const numPoints = 8;
        for (let i = 0; i < numPoints; i++) {
          const angle = (i / numPoints) * Math.PI * 2;
          const radius = this.size * (0.8 + Math.random() * 0.4);
          points.push({
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius
          });
        }
        return points;
      }

      update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.rotation += this.rotationSpeed;

        // Wrap around screen
        if (this.x < -50) this.x = this.canvas.width + 50;
        if (this.x > this.canvas.width + 50) this.x = -50;
        if (this.y < -50) this.y = this.canvas.height + 50;
        if (this.y > this.canvas.height + 50) this.y = -50;
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        this.points.forEach(point => {
          ctx.lineTo(point.x, point.y);
        });
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
    }

    class Ship {
      constructor(canvas) {
        this.canvas = canvas;
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.rotation = -Math.PI / 2;
        this.velocity = { x: 0, y: 0 };
        this.thrust = 0.5;
        this.rotationSpeed = 0.1;
        this.friction = 0.99;
        this.bullets = [];
      }

      update() {
        // Update position
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        // Apply friction
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;

        // Wrap around screen
        if (this.x < 0) this.x = this.canvas.width;
        if (this.x > this.canvas.width) this.x = 0;
        if (this.y < 0) this.y = this.canvas.height;
        if (this.y > this.canvas.height) this.y = 0;

        // Update bullets
        this.bullets = this.bullets.filter(bullet => {
          bullet.x += Math.cos(bullet.rotation) * 10;
          bullet.y += Math.sin(bullet.rotation) * 10;
          bullet.lifetime--;

          // Wrap bullets around screen
          if (bullet.x < 0) bullet.x = this.canvas.width;
          if (bullet.x > this.canvas.width) bullet.x = 0;
          if (bullet.y < 0) bullet.y = this.canvas.height;
          if (bullet.y > this.canvas.height) bullet.y = 0;

          return bullet.lifetime > 0;
        });
      }

      shoot() {
        this.bullets.push({
          x: this.x + Math.cos(this.rotation) * 20,
          y: this.y + Math.sin(this.rotation) * 20,
          rotation: this.rotation,
          lifetime: 50
        });
      }

      draw(ctx) {
        // Draw ship
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-10, -10);
        ctx.lineTo(-10, 10);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        // Draw bullets
        ctx.fillStyle = 'white';
        this.bullets.forEach(bullet => {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    }

    // Game Variables
    let gameActive = false;
    let canvas = null;
    let ctx = null;
    let ship = null;
    let asteroids = [];
    let particles = [];
    let keys = {};
    let animationFrameId = null;

    function initGame() {
      canvas = document.getElementById('gameCanvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx = canvas.getContext('2d');

      ship = new Ship(canvas);
      asteroids = Array(5).fill().map(() => new Asteroid(canvas));
      particles = [];

      document.addEventListener('keydown', e => keys[e.key] = true);
      document.addEventListener('keyup', e => keys[e.key] = false);
      document.addEventListener('keydown', e => {
        if (e.code === 'Space') ship.shoot();
      });

      gameActive = true;
      gameLoop();
    }

    function gameLoop() {
      if (!gameActive) return;

      // Clear canvas
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update ship
      if (keys['ArrowLeft']) ship.rotation -= ship.rotationSpeed;
      if (keys['ArrowRight']) ship.rotation += ship.rotationSpeed;
      if (keys['ArrowUp']) {
        ship.velocity.x += Math.cos(ship.rotation) * ship.thrust;
        ship.velocity.y += Math.sin(ship.rotation) * ship.thrust;
      }
      ship.update();
      ship.draw(ctx);

      // Update and draw asteroids
      asteroids.forEach(asteroid => {
        asteroid.update();
        asteroid.draw(ctx);
      });

      // Update and draw particles
      ctx.fillStyle = 'white';
      particles = particles.filter(particle => {
        if (particle.update()) {
          ctx.save();
          ctx.translate(particle.x, particle.y);
          ctx.rotate(particle.rotation);
          ctx.globalAlpha = particle.alpha;
          ctx.fillText(particle.char, 0, 0);
          ctx.restore();
          return true;
        }
        return false;
      });

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Window resize handler
    window.addEventListener('resize', () => {
      if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
    });

// Initialize game when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  const worldText = document.getElementById('worldText');

  worldText.addEventListener('click', () => {
    if (!gameActive) {
      const rect = worldText.getBoundingClientRect();
      const chars = 'WORLD'.split('');

      // Create explosion particles
      chars.forEach((char, i) => {
        const x = rect.left + (rect.width * (i + 1)) / (chars.length + 1);
        const y = rect.top + rect.height / 2;
        particles.push(new Particle(x, y, char));
      });

      // Hide the main content and show the game
      document.querySelector('.main-container').style.opacity = '0';
      setTimeout(() => {
        document.querySelector('.main-container').style.display = 'none';
        canvas = document.getElementById('gameCanvas');
        canvas.classList.remove('hidden');
        initGame();
      }, 1000);
    }
  });
});

// Add ESC key handler to exit game
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && gameActive) {
    gameActive = false;
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
    canvas.classList.add('hidden');
    document.querySelector('.main-container').style.display = 'block';
    setTimeout(() => {
      document.querySelector('.main-container').style.opacity = '1';
    }, 0);
  }
});

// GitHub integration code
const githubUsername = 'KozaWorld';

async function fetchGitHubData() {
  try {
    const reposResponse = await fetch(`https://api.github.com/users/${githubUsername}/repos`);
    const repos = await reposResponse.json();
    const numberOfRepos = repos.length;

    const eventsResponse = await fetch(`https://api.github.com/users/${githubUsername}/events/public`);
    const events = await eventsResponse.json();
    const numberOfContributions = events.filter(event => event.type === "PushEvent").length;

    const projectXP = numberOfRepos * 50;
    const contributionXP = numberOfContributions * 10;
    const totalXP = projectXP + contributionXP;

    let level = Math.floor(totalXP / 100);
    let expToNextLevel = totalXP % 100;

    document.getElementById("level").textContent = `Level: ${level}`;
    document.getElementById("exp").textContent = `Exp: ${totalXP}`;
    document.getElementById("exp-fill").style.width = `${(expToNextLevel / 100) * 100}%`;
  } catch (error) {
    console.error('Error fetching GitHub data:', error);
  }
}

// Function to load projects from JSON
async function loadProjects() {
  try {
    const response = await fetch('projects.json');
    const data = await response.json();
    const projectsGrid = document.getElementById('projects-grid');

    projectsGrid.innerHTML = data.projects.map(project => `
          <div class="bg-gradient-to-br from-gray-800 to-gray-700 p-6 rounded-lg hover:shadow-xl hover:shadow-purple-500/20 transition-all">
            <h3 class="text-xl font-bold mb-2 text-purple-400">${project.title}</h3>
            <p class="mb-4 text-gray-300">${project.description}</p>
            <a href="${project.link}" target="_blank" rel="noopener noreferrer" class="text-purple-400 hover:text-purple-300">
              View Project
            </a>
          </div>
        `).join('');
  } catch (error) {
    console.error('Error loading projects:', error);
  }
}

// Initialize everything
fetchGitHubData();
loadProjects();
</script> </body> </html>
